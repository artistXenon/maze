
<HTML>
    <HEAD>
        <title>Weighted Randomized Kruskal Maze Generation</title>
        <meta name="copyright" content="Matthew Timmermans">
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
        <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
        <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
        <!--
            Copyright 2017 Matthew Timmermans
            
            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at
            
                http://www.apache.org/licenses/LICENSE-2.0
            
            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.
        -->
        
        
        <style>
            table.wrap {
                margin-bottom: 16px;
            }
            .weights .readout {
                font-size:0.8em;
                font-family: monospace;
                margin-left:4px;
                padding-right: 10px;
                text-align: right;
            }
            .weights .label {
                padding-left: 12px;
            }
            .weights td {
                padding: 4px 0;
            }
            .buttons {
                vertical-align: middle;
            }
            .buttons .button {
                padding: 4px 8px;
                margin: 3px 0;
                width: 100%;
            }
            .buttons .solveButton {
                padding: 8px 8px;
                margin: 0 12px;
                width: 100%;
            }
            span.L3 {
                display:inline-block;
                height:16px;
                width:8px;
                border-right: 2px solid black;
            }
            span.R3{
                display:inline-block;
                height:16px;
                width:8px;
                border-left: 2px solid black;
            }
            span.R2 {
                display:inline-block;
                height:7px;
                width:8px;
                border-left: 2px solid black;
                border-top: 2px solid black;
            }
            span.L2 {
                display:inline-block;
                height:7px;
                width:8px;
                border-right: 2px solid black;
                border-top: 2px solid black;
            }
            span.L1 {
                display:inline-block;
                height:7px;
                width:10px;
                border-top: 2px solid black;
            }
            span.H {
                display:inline-block;
                height:7px;
                width:10px;
                border-top: 2px solid #CCC;
            }
            @media print {
                .noprint {display: none;}
            }
        </style>
    </HEAD>
    <BODY>
        <table class="wrap noprint">
            <tr>
                <td></td>
                <td class="buttons">
                    <input type="button" class="button" value="New Maze" onclick="init();">
                </td>
                <td class="buttons">
                    <input type="button" class="solveButton" value="Solve" onclick="initSolution();">
                    <input type="button" class="solveButton" value="Unslove" onclick="resetSolution();">
                </td>
            </tr>
        </table>

        <canvas width="800" height="1000" id="canvas"></canvas>

        <script>
            class Maze {
                width; 
                height;

                weights;
                data;

                // private
                wallqs;
                union;

                constructor(
                    w = 27, h = 18, 
                    weights = {
                        PV33: 12, PV23: 10, PV13: 14, 
                        PV22: 10, PV12: 8, PV11: 2
                    }, 
                    data = undefined
                ) {
                    const size = w * h * 2;
                    this.width = w;
                    this.height = h;
                    if (data && data.length === size) this.data = data;
                    else this.data = new Array(size);
                    const {
                        PV33, PV23, PV13, 
                        PV22, PV12, 
                        PV11 
                    } = weights;
                    this.weights = [
                        PV33, PV23, PV13, 
                        PV23, PV22, PV12, 
                        PV13, PV12, PV11
                    ];
                    for (let i = 0; i < this.weights.length; i++) {
                        this.weights[i] = Math.pow(2.0, this.weights[i] * 0.5);
                    }
                }

                getWall({ x, y, vertical }) {
                    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                        return this.data[(y * this.width + x) * 2 + (vertical ? 0 : 1)];
                    }
                    return null;
                }

                getNeighbours(wall_pos) {
                    const { x, y, vertical } = wall_pos;
                    return vertical ? [
                        { x, y: y - 1, vertical: false },
                        { x, y: y - 1, vertical: true },
                        { x: x + 1, y: y - 1, vertical: false },
                        { x, y, vertical: false },
                        { x, y: y + 1, vertical: true },
                        { x: x + 1, y, vertical: false }
                    ] : [
                        { x: x - 1, y, vertical: true },
                        { x: x - 1, y, vertical: false },
                        { x: x - 1, y: y + 1, vertical: true },
                        { x, y, vertical: true },
                        { x: x + 1, y, vertical: false },
                        { x, y: y + 1, vertical: true }
                    ]
                }

                tryWall(wall_pos) { 
                    const { x, y, vertical } = wall_pos;
                    const wall = this.getWall(wall_pos);
                    if (wall.clr) return false;

                    const c1 = y * this.width + x;
                    const c2 = c1 + (vertical ? 1 : this.width);

                    if (!this.union.union(c1, c2)) return false;

                    wall.clr = true;

                    const neighbours = this.getNeighbours(wall_pos);
                    for (const neighbour of neighbours) {
                        const wall_detail = this.getWall(neighbour);
                        if (!wall_detail) continue;

                        const wall_neighbours = this.getNeighbours(neighbour);
                        const t1 = this.getWallEndType(wall_neighbours[0], wall_neighbours[1], wall_neighbours[2]);
                        const t2 = this.getWallEndType(wall_neighbours[3], wall_neighbours[4], wall_neighbours[5]);
                        const typ = t1 * 3 + t2;

                        if (typ <= wall_detail.typ) continue;
                        wall_detail.typ = typ;
                        randomInsert(this.wallqs[typ], neighbour);
                    }
                    return true;
                }

                getWallEndType(...w) {
                    const c = w.map(wall => {
                        const t = this.getWall(wall);
                        return t && t.clr;
                    });
                    if (c[1] === c[3]) return c[1] ? 2 : 0;
                    else return c[2] ? 2 : 1;
                }

                generate() {
                    this.wallqs = [
                        [], [], [],
                        [], [], [],
                        [], [], []
                    ];

                    let vwall, hwall;
                    for (let y = 0; y < this.height; ++y) {
                        for(let x = 0; x < this.width; ++x) {
                            const base_index = (y * this.width + x) * 2;
                            vwall = null
                            if (x < this.width - 1) {
                                vwall = { typ: 0, clr: false };
                                randomInsert(this.wallqs[0], { x, y, vertical: true });
                            }
                            this.data[base_index] = vwall;

                            hwall = null
                            if (y < this.height - 1) {
                                hwall = { typ: 0, clr: false };
                                randomInsert(this.wallqs[0], { x, y, vertical: false });
                            }
                            this.data[base_index + 1] = hwall;
                        }
                    }

                    //reset union
                    this.union = new Union(this.data.length / 2);

                    while (true) {
                        let w = 0;
                        let chunks = new Array(9);

                        //select a queue randomly, weighted
                        for (let i = 0; i < 9; i++) {
                            chunks[i] = this.wallqs[i].length * this.weights[i];
                            w += chunks[i];
                        }

                        if (w === 0) break;

                        w *= Math.random();
                        chunks.pop();
                        let i = 0;
                        for (const chunk of chunks) {
                            if (w < chunk) break;
                            w -= chunk;
                            i++;
                        }
                        
                        //pop a wall from the queue and try to remove it
                        const wall_pos = this.wallqs[i].pop();
                        const wall = this.getWall(wall_pos);
                        if (wall && wall.typ === i) this.tryWall(wall_pos);
                    }
                    afterMazeGenerate();
                }

                toString() {
                    return JSON.stringify({
                        size: this.width,
                        data: this.data,
                        weights: {
                            PV33: this.weights[0], 
                            PV23: this.weights[1], 
                            PV13: this.weights[2], 
                            PV22: this.weights[4], 
                            PV12: this.weights[5], 
                            PV11: this.weights[8]
                        }
                    })
                }

                static fromString(str) {
                    const o = JSON.parse(str);
                    if (!(
                        o.size && o.data && 
                        typeof o.size === "number" && 
                        Array.isArray(o.data) && 
                        o.data.length % (o.size * 2) === 0
                    )) {
                        throw new Error("corrupt serialization");
                    }
                    return new Maze(o.size, o.data.length / (o.size * 2), o.weights, o.data);

                }
            }

            class Union {
                array;
                constructor(size) {
                    this.array = new Array(size).fill(-1);
                }

                /*
                * # util
                * Union-find implementation
                * so we know when removing a wall will connect disconnected parts of the maze 
                */
                find(cell) {
                    let t, src = cell;
                    const paths = [];
                    // find root
                    while ((t = this.array[cell]) > -1 ) {
                        cell = t;
                        paths.push(t);
                    }

                    // link children to root 
                    for (const path of paths) {
                        if (path === cell) break;
                        this.array[path] = cell;
                    }
                    return cell;
                }

                union(cell1, cell2) {
                    let 
                        i = this.find(cell1),
                        j = this.find(cell2);
                    if (i === j) return false;
                    if (this.array[i] < this.array[j]) {
                        let k = i;
                        i = j;
                        j = k;
                    }
                    this.array[j] += this.array[i];
                    this.array[i] = j;
                    return true;
                }
            }

            class Solver {
                maze;
                constructor(maze) {
                    this.maze = maze;
                }

                generateDepthMap(start = { x: this.maze.width - 1, y: 0 }) {
                    const walldiff = [1 - this.maze.width * 2, 0, -2, 1]; // (0, -1)h, (0, 0)v, (-1, 0)v, (1, 0)h
                    const neighbour_pos = [[0, -1], [1, 0], [-1, 0], [0, 1]];

                    const solution_state = new Array(this.maze.height);
                    
                    for (let y = 0; y < this.maze.height; y++) {
                        solution_state[y] = new Array(this.maze.width).fill(0);
                    }
                    let level = [[start.x, start.y]];
                    solution_state[start.y][start.x] = 1;

                    let depth = 1;
                    let treeCount = 1;

                    while (true) {
                        depth++;
                        const oldLevel = level;
                        level = [];

                        for (let i = 0; i < oldLevel.length; ++i) {
                            const pos = oldLevel[i];
                            const cx = pos[0];
                            const cy = pos[1];
                            const wallr = (cy * this.maze.width + cx) * 2;
                            for (let n = 0; n < 4; n++) {
                                const tx = cx + neighbour_pos[n][0];
                                const ty = cy + neighbour_pos[n][1];
                                if (
                                    tx >= 0 && tx < this.maze.width && 
                                    ty >= 0 && ty < this.maze.height && 
                                    solution_state[ty][tx] === 0 &&
                                    this.maze.data[wallr + walldiff[n]].clr
                                ) {
                                    treeCount++;
                                    level.push([tx, ty]);
                                    solution_state[ty][tx] = depth;
                                }
                            }
                        }

                        const fullTree = treeCount === this.maze.data.length / 2;
                        if (fullTree || level.length === 0) break;
                    }
                    return { state: solution_state, depth };
                }
            }

            let maze, solver;

            //slider values
        
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");

            const resolution = 6;
            let wall_width;       
            
            /*
            * # util
            * Add an element to a randomly permuted array
            */
            function randomInsert(arr, item) {
                if (arr.length === 0) {
                    arr.push(item);
                    return;
                }
                const i = Math.floor(Math.random() * (arr.length + 1));
                const arr2 = arr.splice(i);
                arr.push(item, ...arr2);
            }

            /*
            * Fill a wall or cell in the canvas
            */
            function fill(x, y, wx, wy, clr) {
                wx += 1; wy += 1;

                x += (wx >> 1); 
                wx &= 1;

                y += (wy >> 1); 
                wy &= 1;

                let ex, ey;
                
                if (wx) {
                    ex = Math.floor((x + 1) * (canvas.width - wall_width) / maze.width);
                    x = Math.floor(x * (canvas.width - wall_width) / maze.width);
                    x += wall_width;
                } else {
                    x = Math.floor(x * (canvas.width - wall_width) / maze.width);
                    ex = x + wall_width;
                }

                if (wy) {
                    ey = Math.floor((y + 1) * (canvas.height - wall_width) / maze.height);
                    y = Math.floor(y * (canvas.height - wall_width) / maze.height);
                    y += wall_width;
                } else {
                    y = Math.floor(y * (canvas.height - wall_width) / maze.height);
                    ey = y + wall_width;
                }

                ctx.fillStyle = clr;
                ctx.fillRect(x, y, ex - x, ey - y);
            }
            
            /*
            * Set up and start a new maze generation
            */
            function init() {
                resetSolution();
                if (!maze) maze = new Maze();
                maze.generate();
            };
            
            /*
            * Do maze generation some work.
            */
            function afterMazeGenerate() {
                // set wall width
                wall_width = Math.floor(100 / (resolution * 3));

                // canvas init
                canvas.width = maze.width * 100 / resolution;
                canvas.height = maze.height * 100 / resolution;
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // draw
                fill(maze.width - 1, 0, 0, -1, "white");
                fill(0, maze.height - 1, 0, 1, "white");
                for (let y = 0; y < maze.height; ++y) {
                    for (let x = 0; x < maze.width; ++x) {
                        // walls
                        let wall_index = (y * maze.width + x) * 2;
                        let wall = maze.data[wall_index]
                        if (wall && wall.clr) fill(x, y, 1, 0, "white");
                        wall = maze.data[wall_index + 1]
                        if (wall && wall.clr) fill(x, y, 0, 1, "white");

                        // cells
                        fill(x, y, 0, 0, "white");
                    }
                }
            }

            /**
             * reset solution
             */
            function resetSolution() {
                if (!maze) return;
                for (let y = 0; y < maze.height; ++y) {
                    for (let x = 0; x < maze.width; ++x) {
                        fill(x, y, 0, 0, "white");
                    }
                }
            }

            /*
            * Set up and start a new maze solution
            */
            function initSolution(start = { x: maze.width - 1, y: 0 }) {
                resetSolution();

                if (!solver) solver = new Solver(maze);

                const depthMap = solver.generateDepthMap();
                
                afterSolutionGenerate(depthMap);
            };

            function afterSolutionGenerate({ state, depth }, end = { x: 0, y: maze.height - 1 }) {
                const neighbour_pos = [[0, -1], [1, 0], [-1, 0], [0, 1]];
                const walldiff = [1 - maze.width * 2, 0, -2, 1]; // (0, -1)h, (0, 0)v, (-1, 0)v, (1, 0)h

                for (let y = 0; y < maze.height; y++) {
                    for (let x = 0; x < maze.width; x++) {
                        fill(x, y, 0, 0, "hsl(" + (360 * state[y][x] / depth) + "deg, 80%, 70%)");
                    }
                }

                //draw solution
                let x = end.x;
                let y = end.y;
                while (true) {
                    fill(x, y, 0, 0, "#000");
                    const d = state[y][x];
                    const wallr = (y * maze.width + x) * 2;
                    let brk = false;
                    for (let n = 0; n < 4; n++) {
                        const tx = x + neighbour_pos[n][0];
                        const ty = y + neighbour_pos[n][1];
                        if (
                            tx >= 0 && tx < maze.width && 
                            ty >= 0 && ty < maze.height && 
                            state[ty][tx] === d - 1 &&
                            maze.data[wallr + walldiff[n]].clr) {
                            x = tx;
                            y = ty;
                            break;
                        }
                        if (n === 3) brk = true;
                    }
                    if (brk) break;
                }
            }
        </script>

        <script>        
        $(".buttons .button").each(function(){
            $(this).button({});
        });
        init();
        </script>
    </BODY>
</HTML>