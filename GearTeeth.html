<HTML>

<HEAD>
    <title>Ring/Spur gear teeth</title>
    <meta name="copyright" content="Matthew Timmermans">
    <!--
        Copyright 2017 Matthew Timmermans
        
        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        
            http://www.apache.org/licenses/LICENSE-2.0
        
        Unless required by applicable law or agreed to in writing, software
        distributed under the License is distributed on an "AS IS" BASIS,
        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        See the License for the specific language governing permissions and
        limitations under the License.
    -->
    <script>
        //slider values
        const RESOLUTION = 200;
        const MAXLINELEN2 = 1.0 / (RESOLUTION * RESOLUTION);
        const ADEPTH = 9;
        const AMAX = 1.5;
        const DEFAUT_RELIEF_PERCENT = 15;
        let reliefPercent = DEFAUT_RELIEF_PERCENT;
        const DEFAULT_BALANCE_PERCENT = 50;
        let balancePercent = DEFAULT_BALANCE_PERCENT;
        const DEFAUT_PRESSURE_ANGLE = 20;
        var pressureAngle = DEFAUT_PRESSURE_ANGLE;
        const DEFAULT_CONTACT_RATIO = 1.3;
        var contactRatio = DEFAULT_CONTACT_RATIO;
        const DEFAULT_PROFILE_SHIFT_PERCENT = 0;
        var profileShift = DEFAULT_PROFILE_SHIFT_PERCENT;
        const DEFAULT_RING_TEETH = 14;
        var ringTeeth = DEFAULT_RING_TEETH;
        const DEFAULT_SPUR_TEETH = 8;
        var spurTeeth = DEFAULT_SPUR_TEETH;
        var PATHCOLOR = "#2ECC00"
        var animationStartTime = Date.now();

        var rring;
        var rspur;
        var rackCuts;
        var ringRack;
        var spurRack;
        var spurCuts;
        var ringCuts;
        var spurPath;
        var ringPath;
        var spurSvg;
        var ringSvg;

        function update() {
            params = new URLSearchParams((window.location.hash || '').substring(1));
            pressureAngle = numberParam(params, 'pa', 10, 30, DEFAUT_PRESSURE_ANGLE);
            reliefPercent = numberParam(params, 'relief', 0, 50, DEFAUT_RELIEF_PERCENT);
            balancePercent = numberParam(params, 'bp', 0, 100, DEFAULT_BALANCE_PERCENT);
            contactRatio = numberParam(params, 'cr', 1, 2.5, DEFAULT_CONTACT_RATIO);
            profileShift = numberParam(params, 'pshift', -100, 100, DEFAULT_PROFILE_SHIFT_PERCENT);
            ringTeeth = numberParam(params, 'ring', 0, 1000, DEFAULT_RING_TEETH);
            spurTeeth = numberParam(params, 'spur', 0, 1000, DEFAULT_SPUR_TEETH);

            setNumber('pa', pressureAngle);
            setNumber('cr', contactRatio);
            setNumber('ring', ringTeeth);
            setNumber('spur', spurTeeth);
            setNumber('pshift', profileShift);
            setNumber('bp', balancePercent);
            setNumber('relief', reliefPercent);


            rring = ringTeeth * 0.5 / Math.PI;
            rspur = spurTeeth * 0.5 / Math.PI;

            rackCuts = makeRack(false, false);
            ringRack = makeRack(true, false);
            spurRack = makeRack(false, true);

            spurCuts = turnCuts(-AMAX, AMAX, ADEPTH, t =>
                [
                    ...cutsFromRack(t, rspur, shiftCuts(-1, spurRack)),
                    ...cutsFromRack(t, rspur, spurRack),
                    ...cutsFromRack(t, rspur, shiftCuts(1, spurRack)),
                ]
            );
            spurPath = cutsToPath(rspur, spurCuts);
            ringCuts = turnCuts(-AMAX, AMAX, ADEPTH, t =>
                [
                    ...cutsFromRack(t, rring, shiftCuts(-1, ringRack)),
                    ...cutsFromRack(t, rring, ringRack),
                    ...cutsFromRack(t, rring, shiftCuts(1, ringRack)),
                ]
            );
            ringPath = cutsToPath(rring, ringCuts);
        }

        function submit() {
            const fields = [
                ['pa', DEFAUT_PRESSURE_ANGLE],
                ['cr', DEFAULT_CONTACT_RATIO],
                ['ring', -1],
                ['spur', -1],
                ['pshift', DEFAULT_PROFILE_SHIFT_PERCENT],
                ['bp', DEFAULT_BALANCE_PERCENT],
                ['relief', DEFAUT_RELIEF_PERCENT]
            ];
            let parts = [];
            for (const [id, defval] of fields) {
                let val = document.getElementById(id).value.trim();
                if (val !== String(defval)) {
                    parts.push(id + '=' + val);
                }
            }
            let newhash = '#' + parts.join('&');
            if (newhash != window.location.hash) {
                window.location.hash = newhash;
            } else {
                update();
            }
        }

        function downloadRing() {
            if (ringSvg) {
                URL.revokeObjectURL(ringSvg);
                ringSvg = null;
            }
            const svg = pathToSvg(ringPath, rring, ringTeeth);
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            ringSvg = url;
            const a = document.createElement('a');
            a.href = url;
            a.download = `ring${ringTeeth}pa${pressureAngle}.svg`;
            document.body.appendChild(a);
            a.click()
            document.body.removeChild(a);
        }

        function downloadSpur() {
            if (spurSvg) {
                URL.revokeObjectURL(spurSvg);
                spurSvg = null;
            }
            const svg = pathToSvg(spurPath, rspur, spurTeeth);
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            spurSvg = url;
            const a = document.createElement('a');
            a.href = url;
            a.download = `spur${spurTeeth}pa${pressureAngle}.svg`;
            document.body.appendChild(a);
            a.click()
            document.body.removeChild(a);
        }

        function setNumber(id, val) {
            document.getElementById(id).value = String(val);
        }

        function numberParam(params, name, minval, maxval, defval) {
            let v = params.get(name);
            if (v == null) {
                return defval;
            }
            v = Number(v);
            if (isNaN(v)) {
                return defval;
            }
            if (v < minval) {
                return minval;
            }
            if (v > maxval) {
                return maxval;
            }
            return v;
        }

        function makeRack(toprelief, botrelief) {
            const sinPA = Math.sin(pressureAngle * Math.PI / 180.0);
            const cosPA = Math.cos(pressureAngle * Math.PI / 180.0);
            let ah = contactRatio * sinPA;
            let cy = profileShift / (100 * Math.PI);
            let miny = cy - ah / 2;
            let maxy = cy + ah / 2;
            if (toprelief) {
                maxy += reliefPercent / (100 * Math.PI);
            }
            if (botrelief) {
                miny -= reliefPercent / (100 * Math.PI);
            }
            let freew = 0.5 - ah * sinPA;
            const cx = -0.25 - freew * (balancePercent - 50) / 100;
            const topx = (maxy - cy) * sinPA / cosPA + cx;
            const botx = (miny - cy) * sinPA / cosPA + cx;
            const ret = [];
            cutLine(ret, -0.5, miny, botx, miny);
            cutLine(ret, botx, miny, topx, maxy);
            cutLine(ret, topx, maxy, -topx, maxy);
            cutLine(ret, -topx, maxy, -botx, miny);
            cutLine(ret, -botx, miny, 0.5, miny);
            normalize(ret);
            return ret;
        }

        function turnCuts(tmin, tmax, depth, genfunc) {
            let t = (tmin + tmax) / 2.0;
            let cuts = genfunc(t);
            if (depth > 1) {
                cuts = [
                    ...cuts,
                    ...turnCuts(tmin, t, depth - 1, genfunc),
                    ...turnCuts(t, tmax, depth - 1, genfunc)
                ];
            }
            normalize(cuts);
            if (cuts.length > 1000) {
                cuts = DP(cuts);
            }
            return cuts;
        }

        function cutsToPath(r, cuts) {
            if (!cuts.length) {
                return [];
            }
            let path = cuts.map(cut => wrap(r, cut[0], cut[1]));
            path.push(wrap(r,cuts[cuts.length-1][2],cuts[cuts.length-1][3]));

            if (path.length < 10) {
                return path;
            }
            const out = [path[0]];
            const q = [];
            {
                ie = path.length;
                let i2=Math.floor(ie*.4);
                q.push([ie-i2-1,ie],[i2-1,ie-i2],[0,i2]);
            }
            while (q.length > 0) {
                const [s, e] = q.pop();
                if (e - s < 2) {
                    out.push(path[e-1]);
                    continue;
                }
                const sx = path[s][0];
                const sy = path[s][1];
                const ex = path[e - 1][0];
                const ey = path[e - 1][1];
                let dx = sy - ey;
                let dy = ex - sx;
                const seglen = Math.sqrt(dx * dx + dy * dy);
                dx /= seglen; dy /= seglen;
                let maxpos = 0;
                let maxdev = 0;
                for (let i = s+1; i < e - 1; ++i) {
                    const tx = path[i][0] - ex;
                    const ty = path[i][1] - ey;
                    const dev = Math.abs(tx * dx + ty * dy);
                    if (dev > maxdev) {
                        maxpos = i;
                        maxdev = dev;
                    }
                }
                if (maxdev < 0.0001) {
                    out.push(path[e-1]);
                } else if (maxdev > 0.002 || maxdev > seglen*0.25) {
                    q.push([maxpos, e]);
                    q.push([s, maxpos + 1]);
                } else {
                    out.push(splineApprox(path,s,e));
                }
            }
            return out;
        }

        function splineApprox(path, s, e) {
            const sx = path[s][0];
            const sy = path[s][1];
            const dx = path[e-1][0] - sx;
            const dy = path[e-1][1] - sy;
            const mag2 = dx*dx+dy*dy;

            // make a normalized path with the segment from (0,0) to (1,0)
            const hpath = [];
            for (let i=s+1; i<e-1; i++) {
                const tx = path[i][0]-sx;
                const ty = path[i][1]-sy;
                hpath.push([
                    (tx*dx + ty*dy)/mag2,
                    (ty*dx - tx*dy)/mag2,
                    0
                ]);
            }
            // find max above and below
            let minh=0, maxh=0;
            for (const p of hpath) {
                if (p[1] > maxh) {
                    maxh = p[1];
                }
                if (p[1] < minh) {
                    minh = p[1];
                }
            }
            // the curve will be a parabola with min/max on the maxh+minh line
            // 3a(t-t^2)
            let a = 4*(maxh+minh)/3;
            return [
                sx+dx/3-dy*a,
                sy+dy/3+dx*a,
                sx+dx*2/3-dy*a,
                sy+dy*2/3+dx*a,
                path[e-1][0],
                path[e-1][1]
            ];
        }

        function interpY(cut, x) {
            let t = (x - cut[0]) / (cut[2] - cut[0]);
            return cut[1] + (cut[3] - cut[1]) * t;
        }

        function normalize(cuts) {
            const q = [];
            if (!cuts.length) {
                return cuts;
            }
            for (let cut of cuts) {
                let sx = cut[0];
                let ex = cut[2];
                if (ex == sx) {
                    continue;
                }
                if (ex < sx) {
                    cut[0] = ex;
                    let ty = cut[1];
                    cut[1] = cut[3];
                    cut[2] = sx;
                    cut[3] = ty;
                    sx = ex;
                    ex = cut[2];
                }
                if (sx < 0.0 || sx >= 1.0) {
                    ex -= Math.floor(sx);
                    sx -= Math.floor(sx);
                    cut[0] = sx;
                    cut[2] = ex;
                }
                if (ex > 1.0) {
                    let t = (1.0 - sx) / (ex - sx);
                    let ty = cut[1] + (cut[3] - cut[1]) * t;
                    pqpush(q, [0.0, ty, ex - 1.0, cut[3]]);
                    cut[2] = 1.0;
                    cut[3] = ty;
                }
                if (sx < ex) {
                    pqpush(q, cut);
                }
            }
            cuts.length = 0;
            if (!q.length) {
                return cuts;
            }
            let pending = pqpop(q);
            while (q.length) {
                let next = pqpop(q);
                if (pending[0] < next[0]) {
                    if (pending[2] <= next[0]) {
                        cuts.push(pending);
                        pending = next;
                        continue;
                    }
                    let ty = interpY(pending, next[0]);
                    cuts.push([pending[0], pending[1], next[0], ty]);
                    pending[0] = next[0];
                    pending[1] = ty;
                }
                // pending[0] == next[0]
                if (pending[2] < next[2]) {
                    let ty = interpY(next, pending[2]);
                    pqpush(q, [pending[2], ty, next[2], next[3]]);
                    next[2] = pending[2];
                    next[3] = ty;
                }
                if (next[2] < pending[2]) {
                    let ty = interpY(pending, next[2]);
                    pqpush(q, [next[2], ty, pending[2], pending[3]]);
                    pending[2] = next[2];
                    pending[3] = ty;
                }
                // pending[2] == next[2]
                pending[1] = Math.min(pending[1], next[1]);
                pending[3] = Math.min(pending[3], next[3]);
            }
            cuts.push(pending);
        }

        function toRack(t, r, a, y) {
            var angle = (t - a) / r;
            var sa = Math.sin(angle);
            var ca = Math.cos(angle);
            var pr = y + r;
            var px = -sa * pr;
            var py = ca * pr;
            return [px + t, py - r];
        }

        function shiftCuts(t, cuts) {
            return cuts.map(cut => {
                return [cut[0] + t, cut[1], cut[2] + t, cut[3]];
            });
        }

        function cutsToRack(t, r, cuts) {
            return cuts.map(cut => {
                const [sx, sy] = toRack(t, r, cut[0], cut[1]);
                const [ex, ey] = toRack(t, r, cut[2], cut[3]);
                return [sx, sy, ex, ey];
            });
        }

        function DP(cuts) {
            if (cuts.length < 10) {
                return cuts;
            }
            const out = [];
            const q = [[0, cuts.length]];
            while (q.length > 0) {
                const [s, e] = q.pop();
                if (e - s < 2) {
                    out.push(cuts[s]);
                    continue;
                }
                const sx = cuts[s][0];
                const sy = cuts[s][1];
                const ex = cuts[e - 1][2];
                const ey = cuts[e - 1][3];
                let dx = sy - ey;
                let dy = ex - sx;
                const fac = 1.0 / Math.sqrt(dx * dx + dy * dy);
                dx *= fac; dy *= fac;
                let maxpos = 0;
                let maxdev = 0;
                for (let i = s; i < e - 1; ++i) {
                    const tx = cuts[i][2] - ex;
                    const ty = cuts[i][3] - ey;
                    const dev = Math.abs(tx * dx + ty * dy);
                    if (dev > maxdev) {
                        maxpos = i;
                        maxdev = dev;
                    }
                }
                if (maxdev > 0.00001) {
                    q.push([maxpos + 1, e]);
                    q.push([s, maxpos + 1]);
                } else {
                    cutLine(out, sx, sy, ex, ey);
                }
            }
            return out;
        }

        function cutLine(out, sx, sy, ex, ey) {
            let dx = ex - sx;
            let dy = ey - sy;
            if (dx * dx + dy * dy > MAXLINELEN2) {
                let tx = sx + dx * 0.5;
                let ty = sy + dy * 0.5;
                cutLine(out, sx, sy, tx, ty);
                cutLine(out, tx, ty, ex, ey);
            } else {
                out.push([sx, sy, ex, ey]);
            }
        }

        function fromRack(t, r, x, y) {
            var px = x - t;
            var py = y + r;
            var angle = Math.atan(-px / py);
            var pr = Math.sqrt(px * px + py * py);
            var a = t - angle * r;
            return [a, pr - r];
        }

        function cutsFromRack(t, r, cuts) {
            return cuts.map(cut => {
                const [sx, sy] = fromRack(t, r, cut[0], cut[1]);
                const [ex, ey] = fromRack(t, r, cut[2], cut[3]);
                return [sx, sy, ex, ey];
            });
        }

        function wrap(r, a, y) {
            var angle = -a / r;
            var sa = Math.sin(angle);
            var ca = Math.cos(angle);
            var pr = y + r;
            var px = -sa * pr;
            var py = ca * pr;
            return [px, py];
        }

        function rotPoint(angle, x,y) {
            var sa = Math.sin(angle);
            var ca = Math.cos(angle);
            var px = x*ca - y*sa;
            var py = x*sa + y*ca;
            return [px,py];
        }


        function isOrdered(a, b) {
            return a[0] <= b[0];
        }
        function pqpush(q, val) {
            let pos = q.length;
            q.push(val);
            while (pos > 0) {
                let parpos = ((pos - 1) / 2) | 0;
                if (isOrdered(q[parpos], q[pos])) {
                    break;
                }
                let t = q[parpos];
                q[parpos] = q[pos];
                q[pos] = t;
                pos = parpos;
            }
        }
        function pqpop(q) {
            if (!q.length) {
                return undefined;
            }
            if (q.length < 2) {
                return q.shift();
            }
            let ret = q[0];
            q[0] = q.pop();
            let pos = 0;
            let leftpos = 1;
            while (leftpos < q.length) {
                let minpos = pos;
                if (!isOrdered(q[minpos], q[leftpos])) {
                    minpos = leftpos;
                }
                let rightpos = leftpos + 1;
                if (rightpos < q.length && !isOrdered(q[minpos], q[rightpos])) {
                    minpos = rightpos;
                }
                if (minpos == pos) {
                    break;
                }
                let t = q[pos];
                q[pos] = q[minpos];
                q[minpos] = t;
                pos = minpos;
                leftpos = minpos * 2 + 1;
            }
            return ret;
        }

        class CanvasPen {
            constructor(ctx, cx, cy, scale) {
                this.ctx = ctx;
                this.cx = cx;
                this.cy = cy;
                this.scale = scale;
            }
            move(x, y) {
                this.lastx = x * this.scale + this.cx;
                this.lasty = -y * this.scale + this.cy;
                ctx.moveTo(this.lastx, this.lasty);
            }
            line(x, y) {
                this.lastx = x * this.scale + this.cx;
                this.lasty = -y * this.scale + this.cy;
                ctx.lineTo(this.lastx, this.lasty);
            }
            curve(x1, y1, x2, y2, x3, y3) {
                const lx1 = x1 * this.scale + this.cx;
                const ly1 = -y1 * this.scale + this.cy;
                const lx2 = x2 * this.scale + this.cx;
                const ly2 = -y2 * this.scale + this.cy;
                this.lastx = x3 * this.scale + this.cx;
                this.lasty = -y3 * this.scale + this.cy;
                ctx.bezierCurveTo(lx1,ly1,lx2,ly2,this.lastx, this.lasty);
            }
        }

        function drawRack(pen, cuts, shift, mint, maxt) {
            if (!cuts.length) {
                return;
            }
            mint -= shift;
            maxt -= shift;
            start = Math.floor(mint);
            pen.move(cuts[0][0] + start + shift, cuts[0][1]);
            for (let t = start; t < maxt; t++) {
                for (const cut of cuts) {
                    pen.line(cut[2] + t + shift, cut[3]);
                }
            }
        }

        function drawPath(pen, path, r, shift, mint, maxt) {
            if (!path.length) {
                return;
            }
            mint -= shift;
            maxt -= shift;
            start = Math.floor(mint);

            let [x, y] = path[0];
            [x,y] = rotPoint(-(mint+shift)/r, x, y);
            pen.move(x, y-r);
            for (let t = start; t < maxt; t++) {
                for (let seg of path) {
                    if (seg.length < 6) {
                        [x,y] = rotPoint(-(t+shift)/r,seg[0],seg[1]);
                        pen.line(x, y-r);
                    } else {
                        const [x1,y1] = rotPoint(-(t+shift)/r,seg[0],seg[1]);
                        const [x2,y2] = rotPoint(-(t+shift)/r,seg[2],seg[3]);
                        const [x3,y3] = rotPoint(-(t+shift)/r,seg[4],seg[5]);
                        pen.curve(x1, y1-r, x2, y2-r, x3, y3-r);
                    }
                }
            }
        }

        function pathToSvg(path, r, teeth) {
            const S=Math.PI*96/25.4;
            const strs=[
                '<?xml version="1.0" encoding="UTF-8"?>\n',
                '@SVG',
                '<g fill="none" stroke-width="0.04" stroke="blue">\n',
                `<circle cy="0" cx="0" r="${r*S}" id="SvgjsCircle1581"/>\n`,
                '</g>\n',
                '<g fill="none" stroke-width="0.04" stroke="black">\n',
            ];
            let minr2=1;
            let maxr2=1;
            if (path.length) {
                let first = true;
                for (let tooth=0; tooth<teeth; ++tooth) {
                    let ang = -tooth*2*Math.PI/teeth;
                    for (const seg of path) {
                        let r2=0;
                        const [x1,y1] = rotPoint(ang,seg[0]*S,seg[1]*S);
                        if (first) {
                            first = false;
                            r2 = x1*x1 + y1*y1;
                            minr2 = maxr2 = r2;
                            strs.push(`<path d="M ${x1} ${y1} `);
                        } else if (seg.length < 6) {
                            r2 = x1*x1 + y1*y1;
                            strs.push(`L ${x1} ${y1} `);
                        } else {
                            const [x2,y2] = rotPoint(ang,seg[2]*S,seg[3]*S);
                            const [x3,y3] = rotPoint(ang,seg[4]*S,seg[5]*S);
                            r2 = x3*x3 + y3*y3;
                            strs.push(`C ${x1} ${y1} ${x2} ${y2} ${x3} ${y3} `);
                        }
                        if (r2 < minr2) {
                            minr2 = r2;
                        }
                        if (r2 > maxr2) {
                            maxr2 = r2;
                        }
                    }
                }
                strs.push('Z"/>\n');
            }
            strs.push('</g>\n</svg>\n');
            const maxr = Math.ceil(Math.sqrt(maxr2));
            strs[1] = `<svg viewBox="${-maxr} ${-maxr} ${2*maxr} ${2*maxr}" height="${2*maxr}mm" width="${2*maxr}mm" version="1.1" xmlns="http://www.w3.org/2000/svg">\n`;
            return strs.join('');
        }



        /*
         * Set up and start a new maze generation
         */
        function animationFrame() {
            canvas = document.getElementById("canvas");
            const cwid = canvas.width;
            const chei = canvas.height;
            ctx = canvas.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, cwid, chei)
            let scale = cwid / 3;
            const pen = new CanvasPen(ctx, cwid / 2, chei / 2, scale);
            let shift = Date.now() - animationStartTime;
            shift /= 4000;
            shift -= Math.floor(shift);
            ctx.beginPath();
            drawRack(pen, rackCuts, shift, -1.5, 1.5);
            ctx.stroke();
            ctx.beginPath();
            drawPath(pen, spurPath, rspur, shift, -1.5, 1.5);
            ctx.stroke();
            ctx.beginPath();
            drawPath(pen, ringPath, rring, shift, -1.5, 1.5);
            ctx.stroke();
            ctx.restore();
            requestAnimationFrame(animationFrame);
        };

    </script>


    <style>
        .ctrl {
            padding: 3px 0;
        }

        .numin {
            width: 40px;
            margin-left: 32px;
            margin-right: 6px;
        }

        .button {
            margin-left: 32px;
        }

        @media print {
            .noprint {
                display: none;
            }
        }
    </style>
</HEAD>

<BODY>
    <form>
        <table class="wrap noprint">
            <tr>
                <td>
                    <table class="weights">
                        <tr>
                            <td class="ctrl"><input class="numin" id="pa" /></td>
                            <td class="label">
                                Pressure angle (degrees)
                            </td>
                            <td class="ctrl"><input class="numin" id="cr" /></td>
                            <td class="label">
                                Contact Ratio
                            </td>
                        </tr>
                        <tr>
                            <td class="ctrl"><input class="numin" id="ring" /></td>
                            <td class="label">
                                Ring Teeth
                            </td>
                            <td class="ctrl"><input class="numin" id="spur" /></td>
                            <td class="label">
                                Spur Teeth
                            </td>
                        </tr>
                        <tr>
                            <td class="ctrl"><input class="numin" id="pshift" /></td>
                            <td class="label">
                                Profile Shift (Module %)
                            </td>
                            <td class="ctrl"><input class="numin" id="bp" /></td>
                            <td class="label">
                                Width Balance % (0-100)
                            </td>
                        </tr>
                        <tr>
                            <td class="ctrl"><input class="numin" id="relief" /></td>
                            <td class="label">
                                Relief (Module %)
                            </td>
                        </tr>
                        <tr>
                            <td class="ctrl" colspan="2">
                                <input type="submit" id="submit" class="button" value="Submit">
                            </td>
                        </tr>
                        <tr>
                            <td class="ctrl" colspan="2">
                                <input type="button" id="downloadspur" class="button" value="Download Spur">
                                <input type="button" id="downloadring" class="button" value="Download Ring">
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
        </table>
    </form>
    <canvas width="800" height="400" id="canvas"></canvas>

    <script>
        update();
        window.onhashchange = update;
        document.getElementById('submit').onclick = submit;
        document.getElementById('downloadring').onclick = downloadRing;
        document.getElementById('downloadspur').onclick = downloadSpur;
        requestAnimationFrame(animationFrame);
    </script>
</BODY>

</HTML>